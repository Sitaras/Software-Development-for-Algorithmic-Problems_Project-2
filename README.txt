Software-Development-for-Algorithmic-Problems_Project-2 |
—————————————————————————————————————————————————————————
-Ιωάννης Καπετανγεώργης |
 1115201800061 		|
-Δημήτριος Σιταράς	|
 1115201800178 	 	|
————————————————————————————————————————————————————————————————————————————————————————————————————
Github link: https://github.com/giannhskp/Software-Development-for-Algorithmic-Problems_Project-2
————————————————————————————————————————————————————————————————————————————————————————————————————

► Οργάνωση Κώδικα:


.
├── BinaryTree
│   ├── binaryTree.c
│   └── binaryTree.h
│   
├── Clustering
│   ├── clusterHelpingFuns.c
│   ├── clusterHelpingFuns.h
│   ├── clustering.c
│   ├── clustering.h
│   ├── kmeansPlusPlus.c
│   └── kmeansPlusPlus.h
│ 
├── FrechetDistance
│   ├── discreteFrechet.c
│   └── discreteFrechet.h
│   
├── Fred-master
│   └── src
│       ├── config.cpp
│       ├── config.hpp
│       ├── curve.cpp
│       ├── curve.hpp
│       ├── frechet.cpp
│       ├── frechet.hpp
│       ├── interval.cpp
│       ├── interval.hpp
│       ├── my_interface.cpp
│       ├── my_interface.hpp
│       ├── point.cpp
│       ├── point.hpp
│       ├── simplification.cpp
│       ├── simplification.hpp
│       └── types.hpp
│ 
├── Hypercube
│   ├── HashMap
│   │   ├── hashmap.c
│   │   └── hashmap.h
│   ├── hypercube.c
│   └── hypercube.h
│ 
├── LSH
│   ├── helperFunctions.c
│   ├── helperFunctions.h
│   ├── lsh.c
│   ├── lsh.h
│   └── lsh.h.gch
│ 
├── Vector
│   ├── vector.c
│   ├── vector.h
│   └── vector.h.gch
│ 
├── hashTable
│   ├── hashTable.c
│   ├── hashTable.h
│   └── hashTableList
│       ├── hashTableList.c
│       └── hashTableList.h
│       
├── parsing
│   ├── parsingCluster.c
│   ├── parsingCluster.h
│   ├── parsingCube.c
│   ├── parsingCube.h
│   ├── parsingLSH.c
│   └── parsingLSH.h
│ 
├── Makefile
├── README.txt
├── cluster.conf
├── mainCluster.c
├── mainCube.c
├── mainCube.h
├── mainLSH.c
├── mainLSH.h
├── mainPart1.c  
└── unitTesting.c
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

► Γενικά:

	→ Ο κώδικας είναι σχολιασμένος.

	→ Πληρούνται όλες οι προϋποθέσεις / απαιτήσεις που αναγράφονται στην εκφώνηση της άσκησης.

        → Η υλοποίηση του project έγινε με τη χρήση συστήματος διαχείρισης εκδόσεων λογισμικού και συνεργασίας (Git).
          Ο σύνδεσμος του project είναι: https://github.com/giannhskp/Software-Development-for-Algorithmic-Problems_Project-2

	→ Όλη η μνήμη που δεσμεύεται δυναμικά κατά την εκτέλεση του προγράμματος, αποδεσμεύεται πλήρως.
  	  ( Έχει ελεγχθεί μέσω valgrind στα μηχανήματα linux της σχολής. )

	→ Υπάρχει η Απόκρυψη Πληροφορίας που ζητήθηκε στο φροντιστήριο.

	→ Eντολή μεταγλώττισης: make (υπάρχει αρχείο Makefile)

	→ Εντολές εκτέλεσης για κάθε ένα από τα δύο εκτελέσιμα:

				► ./search –i <input file> –q <query file> –k <int> -L <int> -M <int> -probes <int> -ο <output file> -algorithm <LSH or Hypercube or Frechet> -metric <discrete or continuous | only for –algorithm Frechet> -delta <double> -distanceTrueOff
				  ( π.χ. ./search -i nasd_input.csv -q nasd_query.csv -o outLSHDiscreteFrechet -algorithm Frechet -delta 3.25 -metric discrete -k 6 -L 8 -distanceTrueOff )

				► ./cluster –i <input file> –c <configuration file> -o <output file> -update <Mean Frechet or Mean Vector> –assignment <Classic or LSH or Hypercube or LSH_Frechet> -complete <optional> -silhouette <optional>
				  ( π.χ. ./cluster -i nasd_input.csv -c cluster.conf -o outputCluster -update Mean Frechet –assignment LSH ) 

	→ Στο εκτελέσιμο του πρώτου μέρους προστέθηκε η δυνατότητα να δοθεί στη γραμμή εντολών η εξής παράμετρος: -distanceTrueOff, 
	  ώστε να παραλείπεται η εύρεση του πλησιέστερου γείτονα κάθε χρονοσειράς με τον brute force τρόπο.

	→ Tα unit tests υλοποιήθηκαν με χρήση της βιβλιοθήκης CUnit στο αρχείο unitTesting.c, όπου 
	  ουσιαστικά "επαληθεύουμε" την σωστή λειτουργία των παρακάτω συναρτήσεων: 
		- discreteFrechet(...)
		- meanCurveBetween2Curves(...)
		- computeG(...) -> βλεπούμε για το ίδιο διάνυσμα αν μας οδηγεί η ίδια g function στο ίδιο bucket του hash table της δομής LSH
	  
	  Η χρήση της βιβλιοθήκης CUnit προϋποθέτει να έχει πραγματοποιηθεί η εγκατάστασή της, αυτό σε μηχανήματα linux γίνεται μέσω της εντολής:
	  sudo apt-get install libcunit1 libcunit1-doc libcunit1-dev
	
	  Το εκτελέσιμο που παράγεται μέσο της εντολής make είναι το unitTesting και η εντολή εκτέλεσης του είναι η ακόλουθη:
	  ./unitTesting

	→ Υπάρχει η δυνατότητα μεταγλώττισης μόνο των απαραίτητων αρχείων για τα unit tests μέσο της εντολής: make unit_testing	

	→ make clean, για την διαγραφή των παραγόμενων από την μεταγλώττιση αρχείων.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Μέρος Α 
—————————
Το πρώτος μέρος της εργασίας αφορά την αναζήτηση του πλησιέστερου γείτονα μιας χρονοσειράς q εντός ενός 
συνόλου χρονοσειρών με τρεις τεχνικές.
Ο διαχωρισμός των τεχνικών γίνεται στο αρχείο mainLSH.c, καθώς για κάθε τεχνική που ζητείται υπάρχει και 
η αντίστοιχη συνάρτηση που την "υλοποιεί", συγκεκριμένα:

	1. vectorTimeSeriesLSH(...) για το πρώτο ερώτημα.
	2. vectorTimeSeriesLSHFrechetDiscrete(...) για το δεύτερο ερώτημα.
	3. vectorTimeSeriesLSHFrechetContinuous για το τρίτο ερώτημα.

Έτσι, ανάλογα με τις παραμέτρους που δίνει ο χρήστης στην γραμμή εντολών καλείται κάθε φορά η κατάλληλη συνάρτηση
από το αρχείο search.c .
Στην συνέχεια ακολουθεί η επεξήγηση υλοποίησης των τεχνικών/ερωτημάτων.
Οι υλοποιήσεις των LSH και Hypercube είναι ακριβώς ίδιες με την πρώτη εργασία. Η μόνη διαφορά είναι η επιλογή της τιμής του w το οποίο χρησιμοποιείται από τις συναρτήσεις H.
Περισσότερες λεπτομέρειες σχετικά με την τιμή του w εξηγούνται στην συνέχεια στην αντίστοιχη παράγραφο.



▪ Ερώτημα 1ο
———————————————
Σε αυτό το ερώτημα κάθε χρονοσειρά αναπαρίσταται ως διάνυσμα στον ευκλείδιο χώρο R^d, η απόσταση μεταξύ των
διανυσμάτων υπολογίζεται με βάσει της μετρικής L2 και χρησιμοποιούνται οι αλγόριθμοι LSH και Hypercube της πρώτης
εργασίας. Επομένως, αφού έχουμε να ασχοληθούμε καθαρά με διανύσματα η υλοποίηση μας, όσον αναφορά τους αλγορίθμους
LSH και Hypercybe, είναι για την συγκεκριμένη περίπτωση ίδια με αυτή της πρώτης εργασίας.
Η μόνη "διαφορά" που υπάρχει είναι πως για κάθε χρονοσειρά-διάνυσμα αναζητείται ένας πλησιέστερος γείτονας.
Έχουμε προσθέσει στα αρχεία το README της προηγούμενης εργασίας προκειμένου να μπορείτε να ανατρέξετε εύκολα.

▪ Ερώτημα 2ο
———————————————
Σε αυτό το ερώτημα κάθε χρονοσειρά αναπαρίσταται ως πολυγωνική καμπύλη, επομένως δεσμεύουμε για κάθε χρονοσειρά
στo αντίστοιχο struct vec_node τον πίνακα (double* times) για την αποθήκευση του χρόνου, ο χρόνος έχει τιμές απο 0 έως την αντίστοιχη διάσταση των χρονοσειρών και μεταβάλλεταικατά 1.00. Συνεπώς, για κάθε χρονοσειρά αποθηκεύουμε τις τιμές (άξονας y) που υπάρχουν στο αντίστοιχο αρχείο και τον 
χρόνο (άξονας x) που προφανώς είναι ο ίδιο για όλες τις χρονοσειρές. 

Πλέον, για την εισαγωγή των χρονοσειρών αλλά και την αναζήτηση των πλησιέστερων γειτόνων τους χρειάζεται να εφαρμοστεί snapping σε κάθε χρονοσειρά, έτσι
κάθε hash table του LSH έχει θεωρητικά ένα grid, τα grids διαφέρουν μεταξύ τους κατά έναν αριθμό t, ο οποίος παράγεται μέσω της ομοιόμορφης κατανομής.
Τα grids αυτά δεν χρειάζεται να αναπαρασταθούν μέσω κάποιας δομής, καθώς το snapping πραγματοποιείται μέσω της συνάρτησης timeSeriesSnapping() στο αρχείο LSH/lsh.c (αναλύεται στην συνέχεια).
Το μόνο, λοιπόν, που αποθηκεύουμε είναι ένας πίνακας με l αριθμούς t για κάθε διάσταση (struct grid_n στο αρχείο LSH/lsh.c), όπου ο κάθε t αντιστοιχεί σε ένα grid για κάθε ένα hash table του LSH.
Χρησιμοποιούμε διαφορετικό t για κάθε διάσταση, όπως αναφέρθηκε και στο eclass.
Πιο συγκεκριμένα, αφού δουλεύουμε στις δύο διαστάσεις, σε κάθε grid αντιστοιχούν δύο t. Ένα για την τιμή x (χρόνος) και ένα για την τιμή y.
Κάθε χρονοσειρά του input file και του query file πρέπει να περάσει από την διαδικασία του snapping,
ώστε η χρονοσειρά να μετατραπεί τελικά σε διάνυσμα για να εφαρμοστεί στην συνέχεια η εισαγωγή ή η αναζήτηση αντίστοιχα μέσο του LSH.
Συγκεκριμένα, κάθε σημείο (x,y) της χρονοσειράς αντιστοιχίζεται στο κοντινότερο σημείο του πλέγματος (grid) μέσω του τύπου
floor((x-t)/δ + 1/2)*δ + t . Ο τύπος αυτός στην συνάρτηση timeSeriesSnapping() εφαρμόζεται για κάθε συντεταγμένη ξεχωριστά χρησιμοποιώντας το αντίστοιχο t. Αποθηκεύουμε
λοιπόν κάθε τιμή που προκύπτει από τον παραπάνω τύπο στους αντίστοιχους πίνακες προκειμένου να γίνεται ο έλεγχος και 
η διαγραφή των διαδοχικών διπλότυπων σημείων της χρονοσειράς που κάνουν snap στο ίδιο σημείο του grid.
Αν δύο διαδοχικά σημεία γίνουν snap στο ίδιο σημείο του grid, τότε το δεύτερο απαλείφεται. 
Τελικά, προκύπτει έναν διάνυσμα τύπου (x1,y1,x2,y2,...,x2n,y2n), διπλάσιας διάστασης από την αρχική χρονοσειρά.
Βέβαια λόγω της απαλοιφής των διαδοχικών snapped σημείων μπορεί το διάνυσμα αυτό να είναι μικρότερης διάστασης. 
Έτσι στην περίπτωση που δεν υπάρχουν οι τιμές/τα σημεία, λόγω της διαγραφής των διαδοχικών διπλότυπων, ώστε να σχηματίσουν το διάνυσμα που θέλουμε
να παράγουμε τότε κάνουμε padding, συμπληρώνοντας ουσιαστικά το διάνυσμα με μεγάλες τιμές (PADDING_M 1000) για να φτάσουμε στην επιθυμητή διάσταση.
Έτσι, από την συνάρτηση timeSeriesSnapping επιστρέφεται ένα διάνυσμα, το οποίο το δίνουμε ως όρισμα στην συνάρτηση computeG() για να υπολογιστεί
η τιμή της g function, πηγαίνοντας στο αντίστοιχο bucket του hash table κλπ, η διαδικασίας εισαγωγής και αναζήτησης μετά το snapping/padding είναι η ίδια με αυτή της
πρώτη εργασίας.
Επίσης, από κάθε συνάρτηση G εκτός από το index/bucket προκύπτει και ένα ID το οποίο χρησιμοποιείται για το Querying trick (ακριβώς όπως και στην εργασία 1). Δηλαδή για να συγκρίνουμε μόνο curves με ίδιο ID στο εσωτερικό ενός bucket κερδίζοντας έτσι αρκετό χρόνο.


Επιπλέον, για να υπολογίσουμε την απόσταση μεταξύ των δύο διακριτών χρονοσειρών υλοποιούμε την ζητούμενη μετρική discrete
Frechet με χρήση του δυναμικού προγραμματισμού, δηλαδή όπως ακριβώς περιγράφεται στις διαφάνειες του μαθήματος.
Συγκεκριμένα, δημιουργούμε ένα 2-d πίνακα και αρχικοποιούμε την θέση [0][0] με την Ευκλείδια απόσταση (L2) μεταξύ των 2 πρώτων συντεταγμένων
των 2 χρονοσειρών που δίνονται ως είσοδο.
Έπειτα, συμπληρώνουμε την πρώτη γραμμή και την πρώτη στήλη του δυναμικού πίνακα κάνοντας τους αντίστοιχους υπολογισμούς, σύμφωνα με τους 
τύπους : c(1, j) = max{c(1, j − 1),|| p1 − qj ||} και c(i, 1) = max{c(i − 1, 1),|| p1 − qj ||}.
Ακολούθως, συμπληρώνουμε τον υπόλοιπο πίνακα, δηλαδή τα "εσωτερικά" του στοιχεία (i>1 και j>1), με βάση τον τύπο:
c(i, j) = max {min{c(i − 1, j), c(i − 1, j − 1), c(i, j − 1)}, || pi − qj ||}.
Τελικά, η απόσταση μεταξύ των 2 χρονοσειρών έχει υπολογιστεί μέσω του δυναμικού προγραμματισμού και βρίσκεται στο 
κάτω δεξιά στοιχείο του πίνακα, στην θέση [i-1][j-1], συνεπώς αυτήν την τιμή επιστρέφει και η συνάρτηση discreteFrechet() (η οποία βρίσκεται στο αρχείο FrechetDistance/discreteFrechet.c). 
Σημείωση: η απόσταση μεταξύ των συντεταγμένων των χρονοσειρών υπολογίζεται με την Ευκλείδια μετρική (L2).

Η μετρική discrete Frechet στο ερώτημα αυτό εξυπηρετεί τους ίδιους σκοπούς που εξυπηρετούσε η L2 στην πρώτη εργασία (και στο πρώτο ερώτημα),
δηλαδή μέσω αυτή καταφέρνουμε ουσιαστικά να συγκρίνουμε τις χρονοσειρές μεταξύ τους, υπολογίζοντας την μεταξύ τους απόσταση και έτσι
βρίσκουμε τελικά τον πλησιέστερο γείτονα κάθε χρονοσειράς που υπάρχει στο query file.

Επιγραμματικά, οι αλλαγές που έγιναν στην υλοποίηση (σε σχέση με την υλοποίηση του LSH της προηγούμενης εργασίας) για το συγκεκριμένο ερώτημα αναλύθηκαν παραπάνω και είναι:
	
	1) Στην δομή struct vec_node προστέθηκε ένας πίνακας για την αποθήκευση του χρόνου της κάθε χρονοσειράς.
	2) Για να εισαχθεί στην δομή LSΗ ή για να γίνει αναζήτηση του πλησιέστερου γείτονα μέσο της δομής LSΗ, κάθε χρονοσειρά περνάει πρώτα από την διαδικασία του snapping ώστε να μετατραπεί σε διάνυσμα και στην συνέχεια δίνεται σαν όρισμα σε κάθε συνάρτηση G του LSH έτσι ώστε να προκύψει το αντίστοιχο index (και ID) για το κάθε hash Table.
	3) Η απόσταση μεταξύ των χρονοσειρών υπολογίζεται βάσει την μετρικής Discrete Frechet.
	4) Παρατηρήσεις σχετικά με την παράμετρο delta αναφέρονται στην συνέχεια.



▪ Ερώτημα 3ο
———————————————
Σε αυτό το ερώτημα, όπως και στο παραπάνω κάθε χρονοσειρά αναπαρίσταται ως πολυγωνική καμπύλη, επομένως δεσμεύουμε για κάθε χρονοσειρά
στo αντίστοιχο struct vec_node τον πίνακα (double* times) για την αποθήκευση του χρόνου.

Η δομή που χρησιμοποιείται για την αποθήκευση αποτελείται από ένα μοναδικό hash table το οποίο ακολουθεί την λογική του LSH, δηλαδή χρησιμοποιεί μια hash function G η οποία με την σειρά της χρησιμοποιεί k συναρτήσεις h. 
Άρα έχουμε ένα LSH με L=1.
 
Σε χρονοσειρά, πριν από το snapping, εφαρμόζουμε προεπεξεργασία φιλτραρίσματος για την μείωση της 
πολυπλοκότητάς της. Έτσι, έχουμε υλοποιήσει την συνάρτηση filtering(...) στο αρχείο LSH/lsh.c, η οποία δέχεται ως 
όρισμα μια χρονοσειρά και την παράμετρο epsilon ( ορίζεται ως σταθερά στο αρχείο search.c, FILTERING_E 0.1 ).
Στην συγκεκριμένη συνάρτηση, στις τιμές της χρονοσειράς εφαρμόζουμε τον τύπο των διαφανειών, δηλαδή για οποιαδήποτε
a, b, c συνεχόμενα σημεία της χρονοσειράς, αν ισχύει |a-b| <= epsilon και |b-c| <= epsilon τότε διαγράφουμε από την χρονοσειρά το σημείο b.
Επομένως, προκύπτει μια filtered χρονοσειρά με μειωμένα σημεία την οποία επιστρέφει η αντίστοιχη συνάρτηση.

Μετά από το filtering κάθε χρονοσειρά, όπως και στο προηγούμενο ερώτημα, περνάει απο την διαδικασία του snapping, μόνο 
που τώρα υλοποιείται μέσο της συνάρτησης continuousTimeSeriesSnapping(...) ( στο αρχέιο LSH/lsh.c ) και εφαρμόζεται σε αντίθεση με πριν 
μόνο στην y συντεταγμένη της χρονοσειράς.
Εφόσον έχουμε ένα μόνο hash table, έχουμε και ένα μόνο grid. Στο grid αυτό αντιστοιχεί μια μεταβλητή t, η τιμή της οποίας προκύπτει από την κανονική κατανομή (0,δ).
Δηλαδή προβάλουμε την χρονοσειρά στην μία διάσταση με βάση την συντεταγμένη y και εφαρμόζουμε snapping σε ένα μονοδιάστατο grid.  
Επομένως το νέο διάνυσμα που προκύπτει και επιστρέφεται από την εν λόγω συνάρτηση
είναι της μορφής (y1,y2,...yn), ίδιας διάστασης με την χρονοσειρά.
Το snapping προκύπτει εφαρμόζοντας σε κάθε συντεταγμένη τον εξής τύπο: floor( (x + t)/d ) * d
Τέλος, σε αντίθεση με το snapping στην discrete περίπτωση, δεν αφαιρούνται διαδοχικά σημεία τα οποία γίνονται snap στο ίδιο σημείο του grid.

Στην συνέχεια, στο ερώτημα αυτό, κάθε διάνυσμα πλέον ( η χρονοσειρά μέσω του snapping έχει "μετατραπεί" σε διάνυσμα) υφίσταται μια τελευταία επεξεργασία προτού
δωθεί ως όρισμα στην συνάρτηση g για να υπολογιστεί η τιμή της, η διαδικασία αυτή λέγεται minima and maxima και υλοποιείται μέσω της συνάρτησης
minima_maxima(...) στο αρχείο LSH/lsh.c. 
Αναλυτικότερα, η προαναφερόμενη συνάρτηση δέχεται ως όρισμα ένα διάνυσμα και ελέγχει διαδοχικές τριάδες σημείων του διανύσματος.
Για κάθε τριάδα διαδοχικών σημείων (έστω a,b,c) αν τα σημεία αυτά ακολουθούν ανοδική πορεία ή αντίστοιχα καθοδική πορεία τότε το ενδιάμεσο σημείο b απαλείφεται.
Δηλαδή αν a<=b<=c ή a>=b>=c. Αυτό, σαν ενιαίος τύπος μπορεί να γραφεί ως εξής:
αν min(a,c)<=b<=max(a,c) τότε το σημείο b αφαιρείται από το διάνυσμα.
Έτσι, τελικά σχηματίζεται ένα νέο "τριμαρισμένο" διάνυσμα (ίδιας διάστασης με το αρχικό), στο οποίο έχουμε εφαρμόσει και το κατάλληλο padding λόγω των 
τυχών διαγραμμένων τιμών από την παραπάνω διαδικασία.

Το διάνυσμα αυτό δίνεται ως είσοδος στην συνάρτηση G του μοναδικού hash table έτσι ώστε να προκύψει το index του αντίστοιχου bucket καθώς και το ID για το Querying trick.
Αφού βρούμε το index, αποθηκεύουμε στο hash table την αρχική καμπύλη εισόδου (δηλαδή πριν το filtering) η οποία και θα χρησιμοποιηθεί στην συνέχεια για την σύγκριση και υπολογισμό απόστασης με τα queries.

Συνοπτικά η διαδικασία εισαγωγής ενός input curve στην δομή είναι η εξής:
	input curve -> filtering -> snapping -> minima-maxima -> G-function of LSH -> αποθήκευση του input curve στο hash table
Η διαδικασία που ακολουθεί ένα query curve είναι η ίδια με την διαφορά ότι αντί να αποθηκευτεί στο hash table υπολογίζει την απόσταση του με όλα τα curves που είναι αποθηκευμένα στο αντίστοιχο bucket του hash table και έχουν ίδιο ID (Querying trick). Τελικά κρατά αυτό με την μικρότερη απόσταση ως κοντινότερο γείτονα.

Για να υπολογίσουμε την απόσταση μεταξύ των δύο συνεχών χρονοσειρών χρησιμοποιούμε την μετρική Continuous Frechet, η οποία μας δόθηκε 
υλοποιημένη μέσω μιας βιβλιοθήκη C++ από το GitHub, τα αρχεία της βρίσκονται στον φάκελο Fred-master/src. Συνεπώς, για να μπορέσουμε να συνδέσουμε
την βιβλιοθήκη C++ με τα αρχεία μας ( που είναι "γραμμένα" σε C) φτιάξαμε την αντίστοιχη διεπαφή-συνάρτηση, η οποία υλοποιείται στο αρχείο 
my_interface.cpp ( βρίσκεται στον φακελο Fred-master/src) και μας επιστρέφει την αντίστοιχη απόσταση μεταξύ 2 χρονοσειρών υπολογιζόμενη με χρήση της μετρικής Continuous Frechet.
Ουσιαστικά, έχουμε φτιάξει μια συνάρτηση (εν ονόματι compute_continuous_distance(...) ) η οποία δέχεται σαν ορίσματα 4 πίνακες
και 2 ακεραίους, οι πίνακες έχουν τις τιμές των χρονοσειρών και των αντίστοιχων χρόνων, ενώ οι ακέραιοι τις διαστάσεις για τις αντίστοιχες χρονοσειρές που
πρόκειται να δημιουργηθούν. Έτσι, με βάσει των παραπάνω παραμέτρων που περνάμε στην συνάρτηση, δημιουργούμε τελικά δύο αντικείμενα της κλάσης Curve τα c1,c2 , τα οποία προκύπτουν
μέσο των αντικειμένων p1 και p2 της κλάσης Points αξιοποιώντας σε αυτά τις παραμέτρους αντίστοιχα για κάθε χρονοσειρά. Έτσι, με τα αντικείμενα c1,c2 που δημιουργήσαμε 
( τα οποία αναπαριστούν τις αντίστοιχες χρονοσειρές), μας δίνετε πλέον η δυνατότητα να καλέσουμε την συνάρτηση distance(...) της βιβλιοθήκης που μας δίνετε (αφού η συγκεκριμένη συνάρτηση
παίρνει ως ορίσματα 2 αντικέιμενα Curve) ώστε να υπολογιστεί τελικά η ζητούμενη απόσταση μεταξύ των 2 αυτών χρονοσειρών με βάσει της μετρικής Continuous Frechet, αφού υπολιστει αυτή η απόσταση, επιστρέφεται απο τη συνάρτηση
που αποτελεί την "διεπαφή" μας μεταξύ του αρχείου στο οποίο καλείται η συνάρτηση και της βιβλιοθήκης που μας δίνετε. 
Αξίζει να σημειωθεί πως για να δουλέψει σωστά η διεπαφή, δηλαδή να μπορεί να κληθεί από τo αρχείο hashTable/hashTableList/hashTableList.c (πέρα του ότι έγινε το απαραίτητο include: #include "../../Fred-master/src/my_interface.hpp") στο αρχείο κεφαλίδας my_interface.hpp 
δηλώσαμε την συνάρτηση ανάμεσα στα εξής προσδιοριστικά:

#ifdef __cplusplus
extern "C" {
#endif

// function definition 

#ifdef __cplusplus
}
#endif


Η μετρική Continuous Frechet στο ερώτημα αυτό εξυπηρετεί τους ίδιους σκοπούς που εξυπηρετούσε η L2 στην πρώτη εργασία (και στο πρώτο ερώτημα),
δηλαδή μέσω αυτή καταφέρνουμε ουσιαστικά να συγκρίνουμε τις χρονοσειρές μεταξύ τους, υπολογίζοντας την μεταξύ τους απόσταση και έτσι
βρίσκουμε τελικά τον πλησιέστερο γείτονα κάθε χρονοσειράς που υπάρχει στο query file.

Επιγραμματικά, οι αλλαγές που έγιναν στην υλοποίηση (σε σχέση με την υλοποίηση του LSH της προηγούμενης εργασίας) για το συγκεκριμένο ερώτημα αναλύθηκαν παραπάνω και είναι:
	
	1) Στην δομή struct vec_node προστέθηκε ένας πίνακας για την αποθήκευση του χρόνου της κάθε χρονοσειράς.
	2) Για να εισαχθεί στην δομή LSΗ ή για να γίνει αναζήτηση του πλησιέστερου γείτονα μέσο της δομής LSΗ, κάθε χρονοσειρά υφίσταται πρώτα filtering, έπειτα περνάει από την διαδικασία του snapping ώστε να μετατραπεί σε διάνυσμα και τέλος περνάει από την διαδικασία του minima and maxima.
	3) Η απόσταση μεταξύ των χρονοσειρών υπολογίζεται βάσει την μετρικής Continuous Frechet, η υλοποίηση της οποίας δίνεται έτοιμη μέσω μιας βιβλιοθήκης C++.
	4) Παρατηρήσεις σχετικά με την παράμετρο delta αναφέρονται στην συνέχεια.


↪ Διευκρινίσεις και παρατηρήσεις για LSH :
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Έχουμε επιλέξει το μέγεθος του κάθε hash table να είναι ίσο με numberOfVectors/16 , όπου numberOfVectors ο αριθμός των vectors στο αρχείο του dataset.
- Γίνεται όσο το δυνατόν περισσότερη εξοικονόμηση μνήμης. Για παράδειγμα, κάθε vector αποθηκεύεται μόνο μία φορά στην μνήμη και κάθε ένα hash table περιέχει έναν δείκτή στην θέση μνήμης αυτή. Έτσι δεν έχουμε καθόλου data duplication.
- Όσον αφορά την απόδοση, παρατηρούμε ότι το LSH είναι κατά πολύ γρηγορότερο από την εξαντλητική μέθοδο. Το ποσοστό της βελτίωσης του χρόνου εξαρτάται από το μέγεθος του αρχείου εισόδου. Όσο μεγαλύτερο είναι το πλήθος των vectors/curves του input, τόσο γρηγορότερο είναι και το LSH σε σχέση με την εξαντλητική μέθοδο.


→ Επιλογή του w των συναρτήσεων h
- - - - - - - - - - - - - - - - - -
Στα εξής ερωτήματα χρησιμοποιούμε LSH:
	- A.i LSH for vectors
	- A.ii 
	- A.iii (LSH με L=1)
Δηλαδή για το hashing χρησιμοποιούνται συναρτήσεις H.
Ως γνωστών στο LSH οι συναρτήσεις H τις οποίες χρησιμοποιούν τα hash functions G έχουν μια μεταβλητή w.
Η τιμή του w καθορίζεται κατά την αρχή της εκτέλεσης και παραμένει σταθερή.
Με βάση την θεωρία, η βέλτιστη τιμή για το w προκύπτει εν συναρτήσει της μέσης διανυσματικής απόστασης των vectos/curves του input.
Έτσι, στην πρώτη εργασία το υπολογίζαμε με βάση αυτού.
Ωστόσο στην εργασία αυτή παρατηρήσαμε μια διαφορετική συμπεριφορά από το LSH και την τιμή του w.
Συγκεκριμένα παρατηρήσαμε πως ο υπολογισμός του w με βάση την μέση διανυσματική απόσταση δεν ήταν καθόλου αποδοτικός με αποτέλεσμα τα περισσότερα vectors/curves να έχουν διαφορετικά ID με αποτέλεσμα το πρόγραμμα να αδυνατεί να βρεί κοντινότερους γείτονες καθώς προσπερνούσε όλα τα vectors/curves με βάση το Querying trick.
Αφαιρώντας το Querying trick οι χρόνοι πλησίαζαν αυτούς της εξαντλητικής μεθόδου, κάτι που καθιστούσε το LSH αχρείαστο.
Έπειτα από πειραματισμούς με τα αρχεία εισόδου, παρατηρήσαμε τα εξής:
	- Στο μικρό αρχείο nasdaq2017_LQ.csv (διάστασης 119) η μέση απόσταση των vectors/curves είναι περίπου 900 ενώ η βέλτιστη τιμή που παρατηρήσαμε για το w είναι 6.
	- Στο αρχείο εξέτασης nasd_input.csv (διάστασης 729) η μέση απόσταση των vectors/curves είναι περίπου 1000 ενώ η βέλτιστη τιμή που παρατηρήσαμε για το w είναι 200.
	- Στο μεγάλο αρχείο nasdaq2015_2017.csv (διάστασης 729) η μέση απόσταση των vectors/curves είναι περίπου 25000 ενώ η βέλτιστη τιμή που παρατηρήσαμε για το w είναι επίσης 200.
(Η μέση απόσταση των vectors/curves υπολογίζεται σε ένα υποσύνολο του input)
Από τα παραπάνω συμπεραίνουμε ότι η βέλτιστη τιμή του w δεν μπορεί να προκύψει με βάση την μέση απόσταση του input καθώς:
	- Για παρόμοια μέση απόσταση (900/1000) βλέπουμε πολύ μεγάλη διαφορά στο βέλτιστο w (6/200).
	- Για πολύ μεγάλη διαφορά μέσης απόστασης (1000/25000) βλέπουμε το ίδιο βέλτιστο w.
Για τον λόγο αυτό επεκτείναμε την μελέτη μας σχετικά με την εύρεση της βέλτιστης τιμής για το w. Έτσι, με βάση το αρχείο nasdaq2015_2017.csv κατασκευάσαμε νέα datasets τα οποία περιέχουν vectors/curves διαφορετικών διαστάσεων. Πιο συγκεκριμένα κατασκευάσαμε datasets για τις εξής διαστάσεις: 100, 180, 360, 520, 680 και 729 (το αρχικό datasets).
Έπειτα από πολλαπλές εκτελέσεις με διαφορετικές τιμές του w σε κάθε ένα από τα datasets καταλήξαμε στις εξής βέλτιστες τιμές για το w:
	- διάσταση 100 -> βέλτιστο w = 6
	- διάσταση 119 -> βέλτιστο w = 6
	- διάσταση 180 -> βέλτιστο w = 20
	- διάσταση 360 -> βέλτιστο w = 50
	- διάσταση 520 -> βέλτιστο w = 100
	- διάσταση 680 -> βέλτιστο w = 150
	- διάσταση 729 -> βέλτιστο w = 200
Από τα παραπάνω συμπεραίνουμε πως η τιμή του w σχετίζεται άμεσα με την μέγεθος των vectors/curves του input.
Έτσι, βασιζόμενοι στα παραπάνω αποτελέσματα της μελέτης μας, κατασκευάσαμε μια συνάρτηση (wValueCalculation στο αρχείο mainLSH.c) η οποία αναθέτει την βέλτιστη τιμή στο w με βάση το μέγεθος των vectors/curves του input.
Χρησιμοποιώντας αυτήν την συνάρτηση παρατηρήσαμε πολύ καλή απόδοση ανεξαιρέτως του input (δηλαδή του μεγέθους των vectors/curves ή το πλήθος αυτών).

→ Παράμετρος delta
- - - - - - - - - - - - - - - - - -
Τα ερωτήματα A.ii και A.iii, στα οποία εργαζόμαστε πάνω σε curves, χρησιμοποιούν την παράμετρο delta κατά την διαδικασία του snapping.
Η παράμετρος αυτή μπορεί να δοθεί από τον χρήστη κατά την εκτέλεση. Διαφορετικά χρησιμοποιείται η default τιμή η οποία έχουμε ορίσει.
Έπειτα από μελέτη σε διαφορετικά inputs παρατηρήσαμε καλύτερη απόδοση του προγράμματος όταν η τιμή του delta κυμαίνεται στο διάστημα [1,2].
Σαν βέλτιστη τιμή καταλήξαμε στην τιμή 1, την οποία έχουμε θέσει και ως default τιμή για το delta.






Μέρος Β - Clustering
————————————————————————————————
Το δεύτερο μέρος της εργασίας αφορά την συσταδοποιήση των χρονοσειρών με τους ακόλουθους 5 συνδυασμούς:
	1. Αρχικοποίηση: K-means++, Ανάθεση: Lloyd's, Update: υπολογισμός μέσης χρονοσειράς ως διάνυσμα (χρήση της L2 αποκλειστικά)
	2. Αρχικοποίηση: K-means++, Ανάθεση: Lloyd's, Update: υπολογισμός μέσης χρονοσειράς ως καμπύλη (χρήση της Discrete-Frechet Mean Curve of n curves )
	3. Αρχικοποίηση: K-means++, Ανάθεση: Reverse Assignment with LSH, Update: υπολογισμός μέσης χρονοσειράς ως διάνυσμα (χρήση της L2 αποκλειστικά)
	4. Αρχικοποίηση: K-means++, Ανάθεση: Reverse Assignment with LSH, Update: υπολογισμός μέσης χρονοσειράς ως καμπύλη (χρήση της Discrete-Frechet Mean Curve of n curves)
	5. Αρχικοποίηση: K-means++, Ανάθεση: Reverse Assignment with HyperCube, Update: υπολογισμός μέσης χρονοσειράς ως διάνυσμα (χρήση της L2 αποκλειστικά)

Έτσι, ανάλογα με τις παραμέτρους που δίνει ο χρήστης στην γραμμή εντολών εκτελείται κάθε φορά ο ζητούμενος συνδυασμός.
Οι υλοποιήσεις του αλγορίθμου της αρχικοποιήσης K-means++ και των συνδυασμών: 1, 3, και 5 είναι οι ίδιες με αυτές τις 1ης εργασίας καθώς οι χρονοσειρές σε αυτές τις περιπτώσεις
αντιμετωπίζονται ως διανύσματα, συνεπώς δεν θα αναλυθούν στην συνέχεια.
Έχουμε προσθέσει στα αρχεία το README της προηγούμενης εργασίας προκειμένου να μπορείτε να ανατρέξετε εύκολα.
————————————————————————————————

Kάθε χρονοσειρά και στις 2 παρακάτω περιπτώσεις αναπαρίσταται ως πολυγωνική καμπύλη, επομένως δεσμεύουμε για κάθε χρονοσειρά
στo αντίστοιχο struct vec_node τον πίνακα (double* times) για την αποθήκευση του χρόνου.

Στις μεθόδους 2 και 4 ο υπολογισμός της απόστασης μεταξύ δύο καμπυλών γίνεται μέσω της μετρικής Discrete Frechet η υλοποίηση της οποίας έχει αναλυθεί παραπάνω.


``` Σε σχέση με την 1η εργασία αλλάζει μόνο ο τρόπος υπολογισμού των mean curves ΕΔΩ ΕΙΝΑΙ ΤΟ ΨΩΜΙ 
    KAI ΓΕΝΙΚΑ για τον  υπολογισμό των αποστάσεων μεταξύ των curves χρησιμοποιείται η μετρική Discrete Frechet 
    ΕΧΕΙ ΑΝΑΛΥΘΕΙ ΣΤΟ PART 1 ```

→ Lloyd's, 
  Update: υπολογισμός μέσης χρονοσειράς ως καμπύλη (χρήση της Discrete-Frechet Mean Curve of n curves )
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 


→ Reverse Assignment with LSH,
  Update: υπολογισμός μέσης χρονοσειράς ως καμπύλη (χρήση της Discrete-Frechet Mean Curve of n curves)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


→ Yπολογισμός μέσης χρονοσειράς ως καμπύλη μεταξύ δυο καμπυλών (Mean curve of 2 curves)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


→ Yπολογισμός μέσης χρονοσειράς ως καμπύλη μεταξύ n καμπυλών (Mean curve of n curves)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



→ Silhouettes
- - - - - - - - - - - - - - - - - 
Ο τρόπος υπολογισμού των silhouettes είναι ακριβώς ίδιος με αυτόν της πρώτης εργασίας, έτσι δεν αναλύεται ξανά.
Η μόνη διαφορά είναι πως στις περιπτώσεις 2 και 4 (δηλαδή όταν εργαζόμαστε με καμπύλες) ο υπολογισμός των αποστάσεων γίνεται χρησιμοποιώντας Discrete Frechet distance. 
Στις υπόλοιπες περιπτώσεις όπου δουλεύουμε με vectors ο υπολογισμός των αποστάσεων γίνεται μέσω της μετρικής L2.
Λόγω του αρκετού χρόνου που χρειάζεται για τον υπολογισμό των silhouettes, δεν υπολογίζονται by default κατά την εκτέλεση.
Εάν θέλουμε να υπολογιστούν πρέπει να εκτελέσουμε το πρόγραμμα δίνοντας την επιπλέον παράμετρο -silhouette στο command line.


	↪ Διευκρινίσεις και παρατηρήσεις :

	- Οι παραπάνω αλγόριθμοι ουσιαστικά διαφέρουν μονό στο βήμα της ανάθεσης των διανυσμάτων στα αντίστοιχα clusters. Η αρχικοποίηση (kmeans++) και η εύρεση του μέσου παραμένει ίδια και στους 3 αλγορίθμους που υλοποιήσαμε.
	- Στην λίστα με τα conflicts πιθανόν υπάρχουν διπλότυποι κόμβοι που αφορούν τα ίδια διανύσματα, όταν όμως πραγματοποιηθεί η ανάθεση ενός διανύσματος σε ένα cluster, τότε στο πεδίο της ακτίνας (assignedAtRadius) του διανύσματος αποθηκεύεται
	  η τιμή -3.0, έτσι αν ξανά συναντηθεί στην λίστα το ίδιο διάνυσμα με έναν έλεγχο (getAssignedAtRadius(temp->v)<-1.0) καταφέρνουμε απλά να παραλείπεται.
	- Τα hash tables που χρησιμοποιούνται στις υλοποιήσεις των αλγορίθμων reverse assignment with LSH and Hypercube είναι τα ίδια με αυτά που χρησιμοποιούνται στο Α μέρος της εργασίας.
	- Κάθε vector αποθηκεύεται μόνο μία φορά στην μνήμη και κάθε μία δομή που χρησιμοποιείται (hash table ή list ανάλογα) περιέχει έναν δείκτή στην θέση μνήμης αυτή.
