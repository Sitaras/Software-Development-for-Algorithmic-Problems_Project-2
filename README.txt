Software-Development-for-Algorithmic-Problems_Project-2 |
—————————————————————————————————————————————————————————
-Ιωάννης Καπετανγεώργης |
 1115201800061 		|
-Δημήτριος Σιταράς	|
 1115201800178 	 	|
————————————————————————————————————————————————————————————————————————————————————————————————————
Github link: https://github.com/giannhskp/Software-Development-for-Algorithmic-Problems_Project-2
————————————————————————————————————————————————————————————————————————————————————————————————————

► Οργάνωση Κώδικα:


.
├── BinaryTree
│   ├── binaryTree.c
│   └── binaryTree.h
│   
├── Clustering
│   ├── clusterHelpingFuns.c
│   ├── clusterHelpingFuns.h
│   ├── clustering.c
│   ├── clustering.h
│   ├── kmeansPlusPlus.c
│   └── kmeansPlusPlus.h
│ 
├── FrechetDistance
│   ├── discreteFrechet.c
│   └── discreteFrechet.h
│   
├── Fred-master
│   └── src
│       ├── config.cpp
│       ├── config.hpp
│       ├── curve.cpp
│       ├── curve.hpp
│       ├── frechet.cpp
│       ├── frechet.hpp
│       ├── interval.cpp
│       ├── interval.hpp
│       ├── my_interface.cpp
│       ├── my_interface.hpp
│       ├── point.cpp
│       ├── point.hpp
│       ├── simplification.cpp
│       ├── simplification.hpp
│       └── types.hpp
│ 
├── Hypercube
│   ├── HashMap
│   │   ├── hashmap.c
│   │   └── hashmap.h
│   ├── hypercube.c
│   └── hypercube.h
│ 
├── LSH
│   ├── helperFunctions.c
│   ├── helperFunctions.h
│   ├── lsh.c
│   ├── lsh.h
│   └── lsh.h.gch
│ 
├── Vector
│   ├── vector.c
│   ├── vector.h
│   └── vector.h.gch
│ 
├── hashTable
│   ├── hashTable.c
│   ├── hashTable.h
│   └── hashTableList
│       ├── hashTableList.c
│       └── hashTableList.h
│       
├── parsing
│   ├── parsingCluster.c
│   ├── parsingCluster.h
│   ├── parsingCube.c
│   ├── parsingCube.h
│   ├── parsingLSH.c
│   └── parsingLSH.h
│ 
├── Makefile
├── README.txt
├── cluster.conf
├── mainCluster.c
├── mainCube.c
├── mainCube.h
├── mainLSH.c
├── mainLSH.h
├── mainPart1.c  
└── unitTesting.c
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

► Γενικά:

	→ Ο κώδικας είναι σχολιασμένος.

	→ Πληρούνται όλες οι προϋποθέσεις / απαιτήσεις που αναγράφονται στην εκφώνηση της άσκησης.

        → Η υλοποίηση του project έγινε με τη χρήση συστήματος διαχείρισης εκδόσεων λογισμικού και συνεργασίας (Git).
          Ο σύνδεσμος του project είναι: https://github.com/giannhskp/Software-Development-for-Algorithmic-Problems_Project-2

	→ Όλη η μνήμη που δεσμεύεται δυναμικά κατά την εκτέλεση του προγράμματος, αποδεσμεύεται πλήρως.
  	  ( Έχει ελεγχθεί μέσω valgrind στα μηχανήματα linux της σχολής. )

	→ Υπάρχει η Απόκρυψη Πληροφορίας που ζητήθηκε στο φροντιστήριο.

	→ Eντολή μεταγλώττισης: make (υπάρχει αρχείο Makefile)

	→ Εντολές εκτέλεσης για κάθε ένα από τα δύο εκτελέσιμα:

				► ./search –i <input file> –q <query file> –k <int> -L <int> -M <int> -probes <int> -ο <output file> -algorithm <LSH or Hypercube or Frechet> -metric <discrete or continuous | only for –algorithm Frechet> -delta <double> -distanceTrueOff
				  ( π.χ. ./search -i nasd_input.csv -q nasd_query.csv -o outLSHDiscreteFrechet -algorithm Frechet -delta 3.25 -metric discrete -k 6 -L 8 -distanceTrueOff )

				► ./cluster –i <input file> –c <configuration file> -o <output file> -update <Mean Frechet or Mean Vector> –assignment <Classic or LSH or Hypercube or LSH_Frechet> -complete <optional> -silhouette <optional>
				  ( π.χ. ./cluster -i nasd_input.csv -c cluster.conf -o outputCluster -update Mean Frechet –assignment LSH ) 

	→ Στο εκτελέσιμο του πρώτου μέρους προστέθηκε η δυνατότητα να δωθεί στη γραμμή εντολων η εξής παράμετρος: -distanceTrueOff, 
	  ώστε να παραλείπεται η εύρεση του πλησιέστερου γείτονα κάθε χρονοσειράς με τον brute force τρόπο.

	→ Tα unit tests υλοποιήθηκαν με χρήση της βιβλιοθήκης CUnit στο αρχείο unitTesting.c, όπου 
	  ουσιαστικά "επαληθεύουμε" την σωστή λειτουργία των παρακάτω συναρτήσεων: 
		- discreteFrechet(...)
		- meanCurveBetween2Curves(...)
		- computeG(...) -> βλεπούμε για το ίδιο διάνυσμα αν μας οδηγεί η ίδια g function στο ίδιο bucket του hash table της δομής LSH
	  
	  Η χρήση της βιβλιοθήκης CUnit προϋποθέτει να έχει πραγματοποιηθεί η εγκατάστασή της, αυτό σε μηχανήματα linux γίνεται μέσω της εντολής:
	  sudo apt-get install libcunit1 libcunit1-doc libcunit1-dev
	
	  Το εκτελέσιμο που παράγεται μέσο της εντολής make είναι το unitTesting και η εντολή εκτέλεσης του είναι η ακόλουθη:
	  ./unitTesting

	→ Υπάρχει η δυνατότητα μεταγλώττισης μόνο των απαραίτητων αρχειών για τα unit tests μέσο της εντολής: make unit_testing	

	→ make clean, για την διαγραφή των παραγόμενων από την μεταγλώττιση αρχείων.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Μέρος Α 
—————————
Το πρώτος μέρος της εργασίας αφορά την αναζήτηση του πλησιέστερου γείτονα μιας χρονοσειράς q εντός ενός 
συνόλου χρονοσειρών με τρεις τεχνικές.
Ο διαχωρισμός των τεχνικών γίνεται στο αρχείο mainLSH.c, καθώς για κάθε τεχνική που ζητείται υπάρχει και 
η αντιστοιχη συνάρτηση που την "υλοποιεί", συγκεκριμένα:

	1. vectorTimeSeriesLSH(...) για το πρώτο ερώτημα.
	2. vectorTimeSeriesLSHFrechetDiscrete(...) για το δεύτερο ερώτημα.
	3. vectorTimeSeriesLSHFrechetContinuous για το τρίτο ερώτημα.

Έτσι, ανάλογα με τις παραμέτρους που δίνει ο χρήστης στην γραμμή εντολών καλείται κάθε φορά η κατάλληλη συνάρτηση
από το αρχείο search.c .
Στην συνέχεια ακολουθεί η επεξήγηση υλοποίησης των τεχνικών/ερωτημάτων.



▪ Ερώτημα 1ο
———————————————
Σε αυτό το ερώτημα κάθε χρονοσειρά αναπαρίσταται ως διάνυσμα στον ευκλείδιο χώρο R^d, η απόσταστη μεταξύ των
διανυσμάτων υπολογίζεται με βάσει της μετρικής L2 και χρησιμοποιούνται οι αλγόριθμοι LSH και Hypercube της πρώτης
εργασίας. Επομένως, αφού έχουμε να ασχοληθούμε καθαρά με διανύσματα η υλοποιήση μας, όσον αναφορά τους αλγορίθμους
LSH και Hypercybe, είναι για την συγκεκριμένη περίπτωση ίδια με αυτή της πρώτης εργασίας.
Η μόνη "διαφορά" που υπάρχει είναι πως για κάθε χρονοσειρά-διάνυσμα αναζητείται ένας πλησιέστερος γέιτονας.
Έχουμε προσθέσει στα αρχεία το README της προηγούμενης εργασίας προκειμένου να μπορείτε να ανατρέξετε εύκολα.

▪ Ερώτημα 2ο
———————————————
Σε αυτό το ερώτημα κάθε χρονοσειρα αναπαρίσταται ως πολυγωνική καμπύλη, επομένως προσθέσαμε στo αντίστοιχο struct vec_node έναν 
πίνακα για την αποθήκευση του χρόνου, ο χρόνος έχει τιμές απο 0 έως την αντίστοιχη διάσταση των χρόνοσειρών και μεταβάλλεταικατά 1.00. Συνεπώς, για κάθε χρονοσειρα αποθηκεύουμε τις τιμές (άξονας y) που υπάρχουν στο αντιστοιχο αρχείο και τον 
χρόνο (άξονας x) που προφανώς είναι ο ιδιο για όλες τις χρονοσειρές. 

Πλέον, για την εισαγωγή των χρονοσειρων αλλα και την αναζήτηση των πλησιέστερων γειτονων τους χρειάζεται να εφαρμόστει snapping σε κάθε χρονοσειρά, έτσι
κάθε hash table του LSH έχει θεωρητικά ένα grid, τα grids διαφέρουν μεταξύ τους κατά έναν αριθμό t, ο οποίος παράγεται μέσω της ομοιόμορφης κατανομής.
Τα grids αυτά δεν χρείαζεται να αναπαραστηθουν μέσω κάποιας δομής, καθως το snapping πραγματοποιείται μέσω της συνάρτησης timeSeriesSnapping() στο αρχείο LSH/lsh.c (αναλύεται στην συνέχεια).
Το μόνο, λοιπόν, που αποθηκεύουμε είναι ένας πίνακας με l αριθμούς t (struct grid_n στο αρχείο LSH/lsh.c), όπου ο κάθε t αντιστοιχεί σε ένα hash table του LSH.
Κάθε χρονοσειρά του input file και του query file πρέπει να περάσει απο την διαδικασία του snapping,
ώστε η χρονοσειρά να μετατραπεί τελικά σε διανύσμα για να εφαρμοστεί στην συνέχεια η εισαγωγή ή η αναζήτηση αντίστοιχα μέσο του LSH.
Συγκεκριμένα, κάθε σημείο (x,y) της χρονοσειράς αντιστοιχίζεται στο κοντινότερο σημείο του πλέγματος (grid) μέσω του τύπου
floor((x-t/delta)). Ο τυπος αυτός στην συνάρτηση timeSeriesSnapping() εφαρμόζεται για κάθε συντεταγμένη ξεχωριστά. Αποθηκεύουμε
λοιπον καθε τιμή που προκύπτει απο τον παραπάνω τύπο στους αντίστοιχους πίνακες προκειμένου να γίνεται ο ελεγχος και 
η διαγραφή των διαδοχικων διπλότυπων σημείων της χρονοσειρας που κάνουν snap στο ίδιο σημείο του grid. 
Τελικά, προκύπτει έναν διάνυσμα τυπου (x1,y1,x2,y2,...,x2n,y2n), διπλάσιας διάστασης απο την αρχική χρονοσειρά. Στην
περίπτωση που δεν υπάρχουν οι τιμές/τα σημεία, λόγω της διαγραφής των διαδοχικών διπλότυπων, ώστε να σχηματίσουν το διάνυσμα που θέλουμε
να παράγουμε τότε κανουμε padding, συμπληρώνοντας ουσιαστικά το διανύσμα με μεγάλες τιμες (PADDING_M 300) για να φτάσουμε στην επιθυμητή διάσταση.
Έτσι, απο την συνάρτηση timeSeriesSnapping επιστρέφεται ένα διάνυσμα, το οποίο το δίνουμε ως όρισμα στην συνάρτηση computeG() για να υπολογίστει
η τιμή της g function, πηγαίνοντας στο αντίστοιχο bucket του hash table κλπ, η διαδικασίας εισαγωγής και αναζήτησης μετα το snapping είναι η ίδια με αυτή της
πρώτη εργασίας.


Επιπλέον, για να υπολογίσουμε την απόσταση μεταξύ των δύο διακριτών χρονοσειρών υλοποιούμε την ζητούμενη μετρική discrete
Frechet με χρήση του δυναμικού προγραμματισμού, δηλαδή οπως ακριβώς περιγράφεται στις διαφάνειες του μαθήματος.
Συγκεκριμένα, δημιουργούμε ενα 2-d πίνακα και αρχικοποιόυμε την θέση [0][0] με την Ευκλείδια απόσταση (L2) μεταξύ των 2 πρώτων συντεταγμένων
των 2 χρόνοσειρες που δίνονται ως είσοδο ( βεβαια πλέον ειναι διανύσματα καθως η συνάρτηση εφαρμόζεται αφού έχει προηγηθεί η διαδικασία του snapping για κάθε χρονοσειρα).
Έπειτα, συμπληρώνουμε την πρώτη γραμμή και την πρώτη στήλη του δυναμικού πίνακα κάνοντας τους αντίστοιχους υπολογισμούς, σύμφωνα με τους 
τύπους : c(1, j) = max{c(1, j − 1),|| p1 − qj ||} και c(i, 1) = max{c(i − 1, 1),|| p1 − qj ||}.
Ακολούθως, συμπληρώνουμε τον υπόλοιπο πίνακα, δηλαδή τα "εσωτερικά" του στοιχεία (i>1 και j>1), με βάση τον τύπο:
c(i, j) = max {min{c(i − 1, j), c(i − 1, j − 1), c(i, j − 1)}, || pi − qj ||}.
Τελικά, η απόσταση μεταξύ των 2 χρονοσειρών έχει υπολογιστεί μέσω του δυναμικου προγραμματισμου και βρίσκεται στο 
κάτω δεξία στοιχείο του πίνακα, στην θέση [i-1][j-1], συνεπώς αυτην την τιμή επιστρέφει και η συνάρτηση discreteFrechet() (η οπόια βρίσκεται στο αρχείο FrechetDistance/discreteFrechet.c). 
Σημείωση: η απόσταση μεταξύ των συντεταγμένων των χρονοσειρών υπολογίζεται με την Ευκλείδια μετρική (L2).

Η μετρική discrete Frechet στο ερώτημα αυτό εξυπηρετεί τους ίδιους σκοπούς που εξυπηρετόυσε η L2 στην πρώτη εργασία (και στο πρώτο ερώτημα),
δηλαδή μέσω αυτή καταφέρνουμε ουσιαστικά να συγκρίνουμε τις χρονοσειρές μεταξύ τους, υπολογίζοντας την μεταξυ τους απόσταση και έτσι
βρίσκουμε τελικά τον πλησιέστερο γέιτονα κάθε χρονοσειράς που υπάρχει στο query file.

Επιγραμματικά, οι αλλαγές που έγιναν στην υλοποίηση (σε σχέση με την υλοποιήση του LSH της προηγούμενης εργασίας) για το συγκεκριμένο ερώτημα αναλύθηκαν παραπάνω και είναι:
	
	1) Στην δομή struct vec_node προστέθηκε ένας πίνακας για την αποθήκευση του χρόνου της κάθε χρονοσειράς.
	2) Για να εισαχθεί στην δομή LSΗ ή για να γίνει αναζήτηση του πλησιέστερου γείτονα μέσο της δομής LSΗ, κάθε χρονοσειρα περνάει πρώτα απο την διαδικασία του snapping ώστε να μετατραπεί σε διάνυσμα.
	3) Η απόσταση μεταξύ των χρονοσειρών υπολογίζεται βάσει την μετρικής Discrete Frechet.



▪ Ερώτημα 3ο
———————————————
Σε αυτό το ερώτημα, οπως και στο παραπάνω κάθε χρονοσειρα αναπαρίσταται ως πολυγωνική καμπύλη, επομένως προσθέσαμε στo αντίστοιχο struct vec_node έναν 
πίνακα για την αποθήκευση του χρόνου.

Κάθε χρόνοσειρα υφίσταται, πέρα απο snapping, προεπεξεργασία φιλτραρίσματος για την μείωση της 
πολυπλοκότητάς της. Έτσι, έχουμε υλοποιήσει την συνάρτηση filtering(...) στο αρχείο LSH/lsh.c, η οποία δέχεται ως 
όρισμα μια χρονοσειρά και την παράμετρο epsilon ( ορίζεται ως σταθερά στο αρχείο search.c, FILTERING_E 0.1 ).
Στην συγκεκριμένη συνάρτηση, στις τιμές της χρονοσειράς εφαρμόζουμε τον τύπο των διαφανειών, δηλαδή για οποιαδήποτε
a, b, c συνεχόμενα σημεία της χρονοσειράς, αν ισχυει |a-b| <= epsilon και |b-c| <= epsilon τότε διαγράφουμε από την χρονοσειρά το σημέιο b.
Επομένως, προκύπτει μια filtered χρονοσειρά με μειωμένα σημεία την οποία επιστρέφει η αντίστοιχη συνάρτηση.

Μετά από το filtering κάθε χρονοσειρά, όπως και στο προηγούμενο ερώτημα, περνάει απο την διαδικασία του snapping, μόνο 
που τώρα υλοποιείται μέσο της συνάρτησης continuousTimeSeriesSnapping(...) ( στο αρχέιο LSH/lsh.c ) και εφαρμόζεται σε αντίθεση με πριν 
μόνο στην y συντεταγμένη της χρονοσειράς, επομένως το νέο διάνυσμα που προκύπτει και επιστρέφεται απο την εν λόγω συνάρτηση
είναι της μορφής (y1,y2,...yn), ίδιας διάστασης με την χρονοσειρά. Ομοίως, με πρίν στην περίπτωση που έχουν διαγραφεί κάποιες συντεταγμένες 
λόγω της διαγραφής των διαδοχικών διπλότυπων, εφαρμόζουμε το κατάλληλο padding ώστε τελικά να μπορέσουμε να σχηματίσουμε το επιθυμητό διάνυσμα.

Τέλος, στο ερώτημα αυτό, κάθε διανύσμα πλεον ( η χρονοσειρά μέσο του snapping "μετατραπεί" σε διάνυσμα) υφίσταται μια τελευταία επεξεργασία πρωτού
δωθεί ως όρισμα στην συνάρτηση g για να υπολογιστεί η τιμή της, η διαδικασία αυτή λέγεται minima and maxima και υλοποιέιται μέσο της συνάρτησης
minima_maxima(...) στο αρχείο LSH/lsh.c. Αναλυτικότερα, η προαναφερόμενη συνάρτηση δέχεται ως όρισμα ένα διάνυσμα στο οποίο για κάθε τρεις διαδοχικές
τιμές a, b, c βρίσκει την μικρότεη και την μεγαλύτερη (τοπικό μέγιστο και ελάχιστο) και στην περίπτωση που η τρίτη 
τιμή δεν βρίσκεται ενδιάμεσα της μέγιστης και την ελάχιστης, η τιμή αυτή ουσιαστικά διαγράφεται. Έτσι, τελικά σχηματίζεται 
ένα νέο "τριμαρισμένο" διάνυσμα (ίδιας διάστασης με το αρχικό), στο οποίο έχουμε εφαρμόσει και το κατάλληλο padding λόγω των 
τυχών διαγραμένων τιμών απο την παραπάνω διαδικασία.

Για να υπολογίσουμε την απόσταση μεταξύ των δύο συνεχών χρονοσειρών χρησιμοποιούμε την μετρική Continuous Frechet, η οποία μας δώθηκε 
υλοποιημένη μέσο μιας βιβλιοθήκη C++ από το GitHub, τα αρχεία της βρίσκονται στον φάκελο Fred-master/src. Συνεπώς, για να μπορέσουμε να συνδέσουμε
την βιβλιοθήκη C++ με τα αρχεία μας ( που ειναι "γραμμένα" σε C) φτιάξαμε την αντίστοιχη διεπαφή-συνάρτηση, η οποία υλοποιείται στο αρχείο 
my_interface.cpp ( βρίσκεται στον φακελο Fred-master/src) και μας επιστρέφει την αντίστοιχη απόσταση μεταξύ 2 χρονοσειρων υπολογιζόμενη με χρήση της μετρικής Continuous Frechet.
Ουσιαστικά, έχουμε φτιάξει μια συνάρτηση (εν ονόματι compute_continuous_distance(...) ) η οποία δέχεται σαν ορισματα 4 πίνακες
και 2 ακεραίους, οι πίνακες έχουν τις τιμές των χρονοσειρων και των χρόνων, ενώ οι ακέραιοι τις διαστάσεις για τις αντίστοιχες χρονοσειρές που
πρόκειται να δημιουργηθούν. Έτσι, με βάσει των παραπάνω παραμέτρων που περνάμε στην συνάρτηση, δημιοργουμέ τελικά δύο αντικείμενα της κλάσης Curve τα c1,c2 , τα οποία προκύπτουν
μέσο των αντικειμένων p1 και p2 της κλάσης Points αξιοποιώντας σε αυτά τις παραμέτρους αντίστοιχα για κάθε χρονοσειρά. Έτσι, με τα αντικέιμενα c1,c2 που δημιουργήσαμε 
( τα οποία αναπαριστούν τις αντιστοιχες χρονοσειρές), μας δίνετε πλεον η δυνατότητα να καλέσουμε την συνάρτηση distance(...) της βιβλιοθήκης που μας δίνετε (αφού η συγκεκριμένη συνάρτηση
παίρνει ως ορίσματα 2 αντικέιμενα Curve) ώστε να υπολογιστεί τελικά η ζητούμενη απόσταση μεταξύ των 2 αυτών χρονοσειρών με βάσει της μετρικής Continuous Frechet, αφού υπολιστει αυτή η απόσταση, επιστρέφεται απο τη συνάρτηση
που αποτελέι την "διεπαφή" μας μεταξύ του αρχείου στο οποίο καλείται η συνάρτηση και της βιβλιοθήκης που μας δίνετε. 
Αξίζει να σημειωθεί πως για να δουλέψει σωστά η διεπαφή, δηλαδή να μπορεί να κληθεί απο τo αρχείο hashTable/hashTableList/hashTableList.c (περα του ότι έγινε το απαραίτητο include: #include "../../Fred-master/src/my_interface.hpp") στο αρχείο κεφαλίδας my_interface.hpp 
δηλώσαμε την συνάρτηση ανάμεσα στα εξής προσδιοριστικά:

#ifdef __cplusplus
extern "C" {
#endif

// function definition 

#ifdef __cplusplus
}
#endif


Η μετρική Continuous Frechet στο ερώτημα αυτό εξυπηρετεί τους ίδιους σκοπούς που εξυπηρετόυσε η L2 στην πρώτη εργασία (και στο πρώτο ερώτημα),
δηλαδή μέσω αυτή καταφέρνουμε ουσιαστικά να συγκρίνουμε τις χρονοσειρές μεταξύ τους, υπολογίζοντας την μεταξυ τους απόσταση και έτσι
βρίσκουμε τελικά τον πλησιέστερο γέιτονα κάθε χρονοσειράς που υπάρχει στο query file.

Επιγραμματικά, οι αλλαγές που έγιναν στην υλοποίηση (σε σχέση με την υλοποιήση του LSH της προηγούμενης εργασίας) για το συγκεκριμένο ερώτημα αναλύθηκαν παραπάνω και είναι:
	
	1) Στην δομή struct vec_node προστέθηκε ένας πίνακας για την αποθήκευση του χρόνου της κάθε χρονοσειράς.
	2) Για να εισαχθεί στην δομή LSΗ ή για να γίνει αναζήτηση του πλησιέστερου γείτονα μέσο της δομής LSΗ, κάθε χρονοσειρα υφίσταται πρώτα filtering, έπειτα περνάει απο την διαδικασία του snapping ώστε να μετατραπεί σε διάνυσμα
	   και τέλος περνάει απο την διαδικασία του minima and maxima.
	3) Η απόσταση μεταξύ των χρονοσειρών υπολογίζεται βάσει την μετρικής Continuous Frechet, η υλοποίηση της οποίας δίνεται έτοιμη μέσω μιας βιβλιοθήκης C++.


↪ Διευκρινίσεις και παρατηρήσεις για LSH :
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Έχουμε επιλέξει το μέγεθος του κάθε hash table να είναι ίσο με numberOfVectors/16 , όπου numberOfVectors ο αριθμός των vectors στο αρχείο του dataset.
- Γίνεται όσο το δυνατόν περισσότερη εξοικονόμηση μνήμης. Για παράδειγμα, κάθε vector αποθηκεύεται μόνο μία φορά στην μνήμη και κάθε ένα hash table περιέχει έναν δείκτή στην θέση μνήμης αυτή. Έτσι δεν έχουμε καθόλου data duplication.
- Όσον αφορά την απόδοση, παρατηρούμε ότι το LSH είναι κατά πολύ γρηγορότερο από την εξαντλητική μέθοδο. Συγκεκριμένα για το αρχείο dataset input_small_id το LSH είναι έως και 100 φορές ταχύτερο,
  ενώ για το αρχείο input_b_id είναι έως και 10000 φορές ταχύτερο.
  Ωστόσο όπως είναι αναμενόμενο υστερεί στην ακρίβεια των αποτελεσμάτων.


→ Επιλογή του w των συναρτήσεων h
- - - - - - - - - - - - - - - - - -
	

Μέρος Β - Clustering
————————————————————————————————



→ Lloyd's (Classic):
- - - - - - - - - - - - - - - - - -



→ Reverse assignment with LSH:
- - - - - - - - - - - - - - - - - -


→ Reverse assignment with Hypecube
- - - - - - - - - - - - - - - - - -



→ Silhouettes
- - - - - - - - - - - - - - - - - 



	↪ Διευκρινίσεις και παρατηρήσεις :

	- Οι παραπάνω αλγόριθμοι ουσιαστικά διαφέρουν μονό στο βήμα της ανάθεσης των διανυσμάτων στα αντίστοιχα clusters. Η αρχικοποίηση (kmeans++) και η εύρεση του μέσου παραμένει ίδια και στους 3 αλγορίθμους που υλοποιήσαμε.
	- Στην λίστα με τα conflicts πιθανόν υπάρχουν διπλότυποι κόμβοι που αφορούν τα ίδια διανύσματα, όταν όμως πραγματοποιηθεί η ανάθεση ενός διανύσματος σε ένα cluster, τότε στο πεδίο της ακτίνας (assignedAtRadius) του διανύσματος αποθηκεύεται
	  η τιμή -3.0, έτσι αν ξανά συναντηθεί στην λίστα το ίδιο διάνυσμα με έναν έλεγχο (getAssignedAtRadius(temp->v)<-1.0) καταφέρνουμε απλά να παραλείπεται.
	- Τα hash tables που χρησιμοποιούνται στις υλοποιήσεις των αλγορίθμων reverse assignment with LSH and Hypercube είναι τα ίδια με αυτά που χρησιμοποιούνται στο Α μέρος της εργασίας.
	- Κάθε vector αποθηκεύεται μόνο μία φορά στην μνήμη και κάθε μία δομή που χρησιμοποιείται (hash table ή list ανάλογα) περιέχει έναν δείκτή στην θέση μνήμης αυτή.
